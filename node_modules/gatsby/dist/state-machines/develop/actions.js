"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.buildActions = exports.markNodesDirty = exports.saveDbState = exports.finishParentSpan = exports.clearWebhookBody = exports.assignWebhookBody = exports.spawnWebpackListener = exports.assignServers = exports.spawnMutationListener = exports.assignServiceResult = exports.markSourceFilesClean = exports.markSourceFilesDirty = exports.markQueryFilesDirty = exports.assignStoreAndWorkerPool = exports.addNodeMutation = exports.callApi = exports.callRealApi = void 0;

var _xstate = require("xstate");

var _actions = require("../../redux/actions");

var _listenForMutations = require("../../services/listen-for-mutations");

var _assertStore = require("../../utils/assert-store");

var _db = require("../../db");

var _reporter = _interopRequireDefault(require("gatsby-cli/lib/reporter"));

var _types = require("../../redux/types");

var _listenToWebpack = require("../../services/listen-to-webpack");

/**
 * These are the deferred redux actions sent from api-runner-node
 * They may include a `resolve` prop (if they are createNode actions).
 * If so, we resolve the promise when we're done
 */
const callRealApi = (event, store) => {
  (0, _assertStore.assertStore)(store);
  const {
    type,
    payload,
    resolve
  } = event;

  if (type in _actions.actions) {
    // If this is a createNode action then this will be a thunk.
    // No worries, we just dispatch it like any other
    const action = _actions.actions[type](...payload);

    const result = store.dispatch(action); // Somebody may be waiting for this

    if (resolve) {
      resolve(result);
    }
  } else {
    _reporter.default.log(`Could not dispatch unknown action "${type}`);
  }
};
/**
 * Handler for when we're inside handlers that should be able to mutate nodes
 * Instead of queueing, we call it right away
 */


exports.callRealApi = callRealApi;

const callApi = ({
  store
}, event) => callRealApi(event.payload, store);
/**
 * Event handler used in all states where we're not ready to process node
 * mutations. Instead we add it to a batch to process when we're next idle
 */


exports.callApi = callApi;
const addNodeMutation = (0, _xstate.assign)({
  nodeMutationBatch: ({
    nodeMutationBatch = []
  }, {
    payload
  }) => {
    // It's not pretty, but it's much quicker than concat
    nodeMutationBatch.push(payload);
    return nodeMutationBatch;
  }
});
exports.addNodeMutation = addNodeMutation;
const assignStoreAndWorkerPool = (0, _xstate.assign)((_context, event) => {
  const {
    store,
    workerPool
  } = event.data;
  return {
    store,
    workerPool
  };
});
exports.assignStoreAndWorkerPool = assignStoreAndWorkerPool;

const setQueryRunningFinished = async () => {
  _actions.boundActionCreators.setProgramStatus(_types.ProgramStatus.BOOTSTRAP_QUERY_RUNNING_FINISHED);
};

const markQueryFilesDirty = (0, _xstate.assign)({
  queryFilesDirty: true
});
exports.markQueryFilesDirty = markQueryFilesDirty;
const markSourceFilesDirty = (0, _xstate.assign)({
  sourceFilesDirty: true
});
exports.markSourceFilesDirty = markSourceFilesDirty;
const markSourceFilesClean = (0, _xstate.assign)({
  sourceFilesDirty: false
});
exports.markSourceFilesClean = markSourceFilesClean;
const assignServiceResult = (0, _xstate.assign)((_context, {
  data
}) => data);
/**
 * This spawns the service that listens to the `emitter` for various mutation events
 */

exports.assignServiceResult = assignServiceResult;
const spawnMutationListener = (0, _xstate.assign)({
  mutationListener: () => (0, _xstate.spawn)(_listenForMutations.listenForMutations, `listen-for-mutations`)
});
exports.spawnMutationListener = spawnMutationListener;
const assignServers = (0, _xstate.assign)((_context, {
  data
}) => {
  return { ...data
  };
});
exports.assignServers = assignServers;
const spawnWebpackListener = (0, _xstate.assign)({
  webpackListener: ({
    compiler
  }) => {
    if (!compiler) {
      return undefined;
    }

    return (0, _xstate.spawn)((0, _listenToWebpack.createWebpackWatcher)(compiler));
  }
});
exports.spawnWebpackListener = spawnWebpackListener;
const assignWebhookBody = (0, _xstate.assign)({
  webhookBody: (_context, {
    payload
  }) => payload === null || payload === void 0 ? void 0 : payload.webhookBody
});
exports.assignWebhookBody = assignWebhookBody;
const clearWebhookBody = (0, _xstate.assign)({
  webhookBody: undefined
});
exports.clearWebhookBody = clearWebhookBody;

const finishParentSpan = ({
  parentSpan
}) => parentSpan === null || parentSpan === void 0 ? void 0 : parentSpan.finish();

exports.finishParentSpan = finishParentSpan;

const saveDbState = () => (0, _db.saveState)();
/**
 * Event handler used in all states where we're not ready to process a file change
 * Instead we add it to a batch to process when we're next idle
 */
// export const markFilesDirty: BuildMachineAction = assign<IBuildContext>({
//   filesDirty: true,
// })


exports.saveDbState = saveDbState;
const markNodesDirty = (0, _xstate.assign)({
  nodesMutatedDuringQueryRun: true
});
exports.markNodesDirty = markNodesDirty;
const buildActions = {
  callApi,
  markNodesDirty,
  addNodeMutation,
  spawnMutationListener,
  assignStoreAndWorkerPool,
  assignServiceResult,
  assignServers,
  markQueryFilesDirty,
  assignWebhookBody,
  clearWebhookBody,
  finishParentSpan,
  spawnWebpackListener,
  markSourceFilesDirty,
  markSourceFilesClean,
  saveDbState,
  setQueryRunningFinished
};
exports.buildActions = buildActions;
//# sourceMappingURL=actions.js.map